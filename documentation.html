<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Documentation Template</title>
    <meta name="description" content="Rhizo Compute">

    <link rel="stylesheet" href="style.css?">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;700&family=Open+Sans:ital,wght@0,400;0,700;1,600&display=swap" rel="stylesheet">
    
    <script defer src="https://use.fontawesome.com/releases/v5.7.2/js/all.js" integrity="sha384-0pzryjIRos8mFBWMzSSZApWtPl/5++eIfzYmTgBBmXYdhvxPc+XcFEk+zJwDgWbP" crossorigin="anonymous"></script>

</head>

<body>

    <div class="navbar clear nav-top">
        <div class="row content">
            <a href="https://www.rhizo.dev"><img class="logo" src="rhizo.png"></a>
            <br><br><br><br><br><a class="right" href="mailto:contact@rhizo.dev" target="_blank"><i class="fas fa-paper-plane"></i>&nbsp;contact@rhizo.dev</a>
        </div>
    </div>

    <div class="container clear">
        <div class="row wrapper">
            <div class="sidepanel">
            <br><br>

                <a class="title" href="#">Introduction</a>
                
                <a class="section" href="#">Supported Versions</a>
                <a class="section" href="#">About Rhizo</a>
                <a class="section" href="#glossary">Glossary</a>                

                <div class="divider left"></div>

                <a class="title" href="#gettingstarted">Getting Started</a>
                <a class="section" href="#installrust">Install Rust</a>
                <a class="section" href="#installsolana">Install Solana Tool Suite</a>
                <a class="section" href="#setupkeypair">Setup a Solana Keypair</a>                
                <a class="section" href="#installcli">Install the CLI</a>       
                <a class="section" href="#installwasix">Install WASIX</a>       

                <div class="divider left"></div>
                <a class="title" href="#basicfeatures">How-to</a>

                <a class="section" href="#configuration">Compile a Module</a>
                <a class="section" href="#compilation">Configure a Route</a>
                <a class="section" href="#compilation">Validating Routes and Modules</a>
                <a class="section" href="#compilation">Testing Modules Locally</a>
                <a class="section" href="#arguments">Deploy Routes</a>
                <a class="section" href="#deploying">Run Your Code</a>
                <a class="section" href="#compilation">Inspect Request Logs</a>
                <a class="section" href="#compilation">Read Arguments in WASM</a>
                <a class="section" href="#async">Write Async Code</a>
                <a class="section" href="#http">Make HTTP Requests</a>
                <div class="divider left"></div>

                <a class="title" href="#advanced">Advanced Features</a>
                <a class="section" href="#configuration">Serve On-chain Data</a>
                <div class ="divider left"></div>
                <a class="title" href="#examples">GitHub Examples</a>
                <a class="section" href="https://github.com/rhizodev/rhizo-hello-world/blob/main/README.md">Hello, World!</a>

             <div class="space double"></div>

            </div>

            <div class="right-col">
                <br><br>
                <p><important><b>Important:</b> Solana requirements are for devnet SOL and can be obtained for free by using <inlinecode>solana airdrop 1</inlinecode>. Rhizo devnet will always remain freely available to developers for testing and prototyping. When Rhizo mainnet launches, the newly launched network will use mainnet SOL.</important></p>
            
                <h1 >Introduction</h1>
                
                <p>Rhizo is decentralized severless infrastructure for hosting, globally distributing, executing, and serving HTTP routes backed by your WebAssembly code. The Rhizo team wishes to pave the way for decentralizing compute power and building powerful infrastructure and features that help developers build at scale without having to worry about operations. Rhizo is currently in an Alpha build. During this time Rhizo will under-go rapid feature additions, specifically in the realm of streaming and storage.<br><br>Remember, as with anything built upon blockchain technologies, data is public and uploaded source code will live on public servers. Don't put anything in your source code or requests you wouldn't want to be found!<br><br>We would like to keep a tight feedback loop with the Rhizo community and understand the needs of our developers. We encourage you to reach out to the team on official channels.</p> 
        
                 
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2>Versions Overview:</h2>
             
                <b>rhizo-cli</b> v0.1.2 The only supported version of rhizo-cli. 
                <br><b>rhizo-server</b> v0.1.0-alpha (Coming soon!) Open sources rhizo-server and decentralizes the network.
                <br><b>rhizo-sdk</b> v0.2.0. The only supported version of rhizo-sdk.
                <br>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2>About Rhizo</h2>
                To jump in head-first check out our <a class="section" href="https://github.com/rhizodev/rhizo-hello-world/blob/main/README.md">Hello, world!</a> example on GitHub. 
                <br><br>Rhizo stores <b>ultra-lightweight</b> WebAssembly modules paired with HTTP route configurations. Arguments to hosted code are provided through traditional HTTP interfaces, as to maintain <b>compatibility</b> with front-ends requesting HTTP resources.
                <br>
                <br>The rhizo network performs load-balancing to tap into the resources of the broader network for <b>scalibility</b>
                <br><br>The rhizo network supports a rapidly growing list of geographic zones. All code lives in all zones by default to maximize <b>availibility</b>. Rhizo plans to add many more zones in the future along with the sub-partitioning of existing zones to better serve end-users. Gateway decentralization is part of our upcoming rhizo-server release and a more formal plan regarding zones will be released at that time. A GeoDNS enabled api.rhizo.dev gateway will be coming soon.
                <br><br>Supported Zones:<ul><li>http://www.usa.rhizo.dev</li><li>http://www.euro.rhizo.dev</li><li>http://www.asia.rhizo.dev</li></ul>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                 <h2>Glossary</h2>
                 <p>
                 <b>Module</b> - WASIX compiled WebAssembly source.
                 <br><br><b>Route CID</b> - Route Content Identifier is a hash derived from the module source code and route config that serves as a unqiue identifier for that module. Route CIDs are identifiers for route in the context of how end-users interact with them via HTTP. The public facing identifier of a route being its source and config content hash gives end-users they confidence they need, knowing that rhizo servers will always be serving consistent logic for their requests.
                 <br><br><b>Route</b> - A queryable HTTP endpoint hosted on Rhizo servers, a route executes a module after verifying that the required arguments were provided and a supported encoding was requested. A route is defined by a TOML file that is deployed along side the backing module.
                 <br><br><b>Public Key</b> - TLDR; your Solana public key is your unique identifier on the Rhizo network
                 <br><br><b>WASM</b> - WebAssembly. In the context of Rhizo, we recommend WASIX compatible WASM to enable network and asynchronous operations 
                 <br><br><b>WASIX</b> - A superset of WebAssembly that enables async programming and network operations.
                 <br><br><b>On-Chain Bytes</b> - On-chain bytes owned by a public key. Owners have the exclusive permission to modify their bytes.
                 <br><br><b>On-Chain PDA</b> - Solana Program Derived Address: the identifier for a slice of on-chain bytes.
                 </p>
                    
        <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h1 id="gettingstarted">Getting Started</h1>

                <h2>Prerequisites</h2>
                
                <p></p> 

                <h2 id="installrust">Install Rust</h2>
                     
                
                   <ol>
                    <li>
                        Follow the official Rust installation instructions from <a href="https://www.rust-lang.org/tools/install">here</a>.
                    </li>
                    <br>
                    <li>
                        Verify your Rust installation with:<br><br>                    <code class="unindent"><bashcmd>rustc</bashcmd> --version && <bashcmd>cargo</bashcmd> --version</code><br> You should see version numbers for each binary.

                    </li>
                </ol>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2 id="installsolana">Install Solana Tool Suite</h2>
                
                
                   <ol>
                    <li>
                        Follow the official Solana installation instructions from <a href="https://docs.solana.com/cli/install-solana-cli-tools">here</a>.
                    </li>
                    <br>
                    <li>
                        Verify your Solana installation with <br><br><code class="unindent"><bashcmd>solana</bashcmd> --version</code> 
                    </li>
                </ol>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2 id="setupkeypair">Setup a Solana Keypair</h2>
                
                
                 <ol>
                    <li>
                        Generate a new keypair with <br><br><code class="unindent"><bashcmd>solana-keygen</bashcmd> new</code><br><br> 
                    </li>
                    <li>
                        Verify your keypair generation with<br><br><code class="unindent"><bashcmd>solana</bashcmd> address</code><br>You should see a base58 encoded Solana address.<br><br> 
                    </li>
                    <li>
                        Open <path>~/.config/solana/cli/config.yml</path> with your favorite text editor.<br>Verify that the value json_rpc_url evaluates to: https://api.devnet.solana.com
                        <br><br><code class="unindent"><tomlvar>json_rpc_url</tomlvar>: https://api.devnet.solana.com</code><br><br> 
                    </li>
                    <li>
                        Airdrop yourself some devnet SOL with <br><br><code class="unindent"><bashcmd>solana</bashcmd> airdrop 1</code><br>
                    </li>
                </ol>
                <div class="divider" style="width:24%; margin:30px 0;"></div>

                <h2 id="installcli">Install the CLI</h2>
                
                 <ol>
                    <li>
                        Install the CLI from cargo <br><br><code class="unindent"><bashcmd>cargo</bashcmd> install rhizo-cli</code><br><br>
                    </li>
                    <li>Install pkg-config and libssl-dev or your OS' variant of these dependencies if they are not already.</li>
                    <li>
                        Verify the installation by running<br><br><code class="unindent"><bashcmd>cargo</bashcmd> rhizo-cli --version</code>
                    </li>
                </ol>
                <div class="divider" style="width:24%; margin:30px 0;"></div>

                <h2 id="installcli">Install WASIX</h2>
             
                 <ol>
                    <li>
                        Follow the <a href="https://wasix.org/docs/language-guide/rust/installation">official WASIX installation instructions</a>. <br><br>
                    </li>
                    <li>
                        Verify installation with
                        <br><br><code class="unindent"><bashcmd>cargo</bashcmd> wasix --version</code>
                    </li>
                </ol>
                <p id="basicfeatures"></p>

                    
            <div class="divider" style="width:24%; margin:30px 0;"></div>
            
            
                <h1>How-to</h1>
                <h2 id="readingarguments">Compile a Module</h2>
                <br><h3>Example:</h3>
                <br>This example is the classic Hello, world! example for Rhizo.
                <br><br><ol>
                    <li>Create a new cargo project<br><br><code class="unindent"><bashcmd>cargo</bashcmd> new helloworld</code><br></li>                    
                    <li>Change directories to your newly created project<br><br><code class="unindent"><bashcmd>cd</bashcmd> helloworld</code><br></li>
                    <li>Add rhizo-sdk as a dependency to your project<br><br><code class="unindent"><bashcmd>cargo</bashcmd> add rhizo-sdk</code><br></li>
                    <li>Let's start with a blank main.rs, clear the contents of this file<br><br><code class="unindent"><bashcmd>echo</bashcmd> "" &gt; src/main.rs</code><br></li>                    
                    <li>Open <path>src/main.rs</path> with your favorite text editor<br><br></li>
                    <li>Import the Rhizo WebAssembly API<br><br><code class="unindent">use <rustvar>rhizosdk</rustvar>::<rusttype>fn_main</rusttype>;</code><br></li>
                    <li>Call the fn_main macro to declare a main function, read the cursor of argument bytes, and return route's response bytes.
                    <br><br><code class="unindent"><rusttype>use</rusttype> <rustvar>std</rustvar>::<rustvar>io</rustvar>::Cursor;<rustcmt>//To read per-request argument bytes from the rhizo-server</rustcmt>
                    <br><br><rustvar>fn_main!</rustvar>({<rustvar>| </rustvar>_<rustvar>: <rusttype>&mut</rusttype> <rusttype>Cursor</rusttype>&lt;<rusttype>&mut</rusttype> <rusttype>[u8]</rusttype>&gt;</rustvar> |</rustvar>  <ruststr>b"Hello, world!"</ruststr>.to_vec() });</code><br>Congratulations! You just finished writing your first Rhizo module.<br><br></li>                    
                    <li>Compile your Rust code to WebAssmebly<br><br><code class="unindent"><bashcmd>cargo</bashcmd> wasix build --release</code><br></li>                    
                </ol>
                        <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2 id="configuration">Configure Routes</h2>
                
                <!--  TODO: point to official rust docs here but provide light overiview and examples-->
                This section focuses on a Rhizo functions' route <a href="https://toml.io/en/">TOML</a> configuration. Now that we've walked through the development flow and compiled WebAssembly code we just need a route configuration before deploying and executing this function on the web. The route configuration will configure how your function interfaces with callers over HTTP on Rhizo servers. 
                    <br>
                    <br>
                    <b>route:</b> String - The route variable is an identifier for your route in the context of route management. Routes are assigned URIs based on their content identifier, which creates trust for the caller in a decentralized hosting environment.
                    <br><br>
                    <b>encodings:</b> <a href="https://docs.rs/rhizo-types/0.1.5/rhizo_types/enum.Encoding.html">Encoding</a> - Encodings indicate what output types you would like your function's route to support.
                    <br>Supported Encodings:<ul><li>texthtml</li><li>textplain</li><li>applicationoctetstream</li><li>applicationjson</li></ul>
                    <br>
                    <b>arguments:</b> Argument - At runtime arguments are parsed from query parameters on the incoming request. These values can be fetched from within the WebAssembly container with the Rhizo API.
                    <br><br><code>{ name: String, argument_type: ArgumentType }</code>
                    <br>Supported ArgumentTypes: <ul>
                        <li>u8 (8-bit unsigned integer)</li>
                        <li>u16 (16-bit unsigned integer)</li>
                        <li>u32 (32 bit unsigned integer)</li>
                        <li>u64 (64 bit unsigned integer)</li>
                        <li>i8 (8-bit signed integer</li>
                        <li>i16 (16-bit signed integer)</li>
                        <li>i32 (32-bit signed integer)</li>
                        <li>i64 (64-bit signed integer)</li>
                        <li>f32 (32-bit floating point)</li>
                        <li>f64 (64-bit floating point)</li>
                        <li>String</li>
                        <li>Vec&lt;ArgumentType&gt;</li>
                        <li>Vec&lt;Vec&lt;ArgumentType&gt;&gt;</li>
                    </ul>
                    <br>See <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">Rust Data Types</a>.
                    <br><br><b>cacheable:</b> bool - Whether or not this route's responses should be cached. Prefer to set this to true. Caching can speed up latencies by orders of magnitude. 
                    <br><br><b>cache_ttl_ms:</b> Option&lt;u64&gt; - The amount of ms your route's responses will be cached. Responses are keyed by the content identifier, and argument values. A None value will mean that a rhizo-server hold a response value for a default value of 1 hour or until evicted by internal processes.
                    <br><br><h3>Examples:</h3>
                    <br><b>Hello, World!</b>
                    <br> This example configuration shows a route that can be reached at /text/html/$MODULE_CID and takes no arguments. This route will have the text/html content-type on its response.
                    <br><br><div><code><tomlvar>route</tomlvar> = <tomlstr>"helloworld"</tomlstr><br><tomlvar>encodings</tomlvar> = [<tomlstr>"texthtml"</tomlstr>] <br><tomlvar>arguments</tomlvar> = []<br><rustcmt># Let's set this to true since the route always serves static content.</rustcmt><br><tomlvar>cacheable</tomlvar> = true <br><rustcmt># cache_ttl_ms = </rustcmt></code></div>
                    <br><b>Multiple Arguments Multiple Encodings</b>
                    <br> This example configuration shows a route that can be reached at /text/plain/$MODULE_CID and application/json/$MODULE_CID. It takes two arguments: search_term of type String and search_urls of type Vec&lt;String&gt;.
                    <br><br><code><tomlvar>route</tomlvar> = <tomlstr>"searchurls"</tomlstr><br><tomlvar>encodings</tomlvar> = [<tomlstr>"textplain"</tomlstr>, <tomlstr>"applicationjson"</tomlstr>]<br><tomlvar>arguments</tomlvar> = [<br>&emsp;&emsp;{ <tomlvar>name</tomlvar> = <tomlstr>"search_term"</tomlstr>, <tomlvar>argument_type</tomlvar> = <tomlstr>"String"</tomlstr> },<br>&emsp;&emsp;{ <tomlvar>name</tomlvar> = <tomlstr>"search_urls"</tomlstr>, <tomlvar>argument_type</tomlvar> = <tomlstr>"Vec&lt;String&gt;"</tomlstr>}<br>]<br><tomlvar>cacheable</tomlvar> = true<br><tomlvar>cache_ttl_ms = 60000</tomlvar></code>
                <br>
                        <div class="divider" style="width:24%; margin:30px 0;"></div>

                <h2 id="validating">Validate Route Configs and Modules</h2>
                rhizo-cli comes with the <inlinecode>validate-module</inlinecode> and <inlinecode>validate-config</inlinecode> commands which allow a developer to understand whether a rhizo-server is capable of parsing and ingesting a route config file or compiled WASM. Provide the path of the resource as an argument to these commands to run a validation. 
                <br><h3>Example</h3>
                <br><br><code><bashcmd>rhizo-cli</bashcmd> validate-module target/wasm32-wasmer-wasi/release/local-rhizo-sdk-test.wasm </code>
                <br><br><code><bashcmd>rhizo-cli</bashcmd> validate-config api.toml</code>
                <br>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2 id="testing">Test Modules Locally</h2>
                rhizo-cli comes with the <inlinecode>test-module</inlinecode> command which allows a developer to run the test function of the WASM module. This section demonstrates best practices within rhizo module test functions. Your test function is expected to be named "test", take no arguments, and no return value. Prefix the function with the no_mangle attribute. Use recommended functions from the SDK to generate output and assert.  
                <br><h3>Example</h3>
                This test function compiles and passes when run with rhizo-cli.
                <br><br><code><bashcmd>rhizo-cli</bashcmd> test-module api.toml</code>
                <br><b>api.toml</b><br><br><code>
                <rustvar>#[no_mangle]</rustvar>
                <br><rusttype>pub fn</rusttype> <rustfn>test</rustfn>() {
                <br>&emsp;&emsp;<rustcmt>// Using rhizosdk::test::tprintln allows your output</rustcmt>
                <br>&emsp;&emsp;<rustcmt>// to show while a test is run with rhizo-cli test-module</rustcmt>
                <br>&emsp;&emsp;<rustvar>rhizosdk</rustvar>::<rustvar>test</rustvar>::<rustfn>tprintln</rustfn>("Your tests go here!");
                <br>&emsp;&emsp;<rustcmt>// To assert within your tests please only use rhizosdk::assert_eq</rustcmt>
                <br>&emsp;&emsp;<rustvar>rhizosdk</rustvar>::<rustvar>test</rustvar>::<rustfn>assert_eq</rustfn>(true, true);
                <br>}
                </code>
                <br>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2 id="deploying">Deploy Routes</h2>
                <p><important><b>Important:</b> While rhizo-server remains an alpha build there will be limitations on the number of routes per pubkey. This limit is enforced by the smart contract and will eventually be lifted. This limit is currently set to 5.</important></p>
                <ol>
                    <li>If you haven't installed the rhizo-cli already run<br><br><code class="unindent"><bashcmd>cargo</bashcmd> install rhizo-cli</code><br></li>                    
                    <li>Deploy your WASIX compiled WebAssembly<br><br><code class="unindent"><bashcmd>cli</bashcmd> deploy target/wasm32-wasmer-wasi/release/$PROJECT_NAME.wasm $PATH_TO_ROUTE_CONFIG</code></li>
                </ol>
                <br>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
               <h2 id="executing">Run your Code</h2>
                    <!-- TODO this needs to be updated too -->
                 Functions can be invoked by requesting their route. A function's route on any Rhizo server will be a concatenation of encoding_type:route_cid.
                 <br><h3>Example</h3>
                 Let's take our Hello, world! example from earlier and assume our route CID is <path>3E7jPTYR8ZhJm7g4kBsbpW5ibXLwmmWX8XKfAdQmhioZ</path>:
                 <br><br><div><code><tomlvar>route</tomlvar> = <tomlstr>"helloworld"</tomlstr><br><tomlvar>encodings</tomlvar> = [<tomlstr>"texthtml"</tomlstr>] <br><tomlvar>arguments</tomlvar> = []<br><rustcmt># Let's set this to true since the route always serves static content.</rustcmt><br><tomlvar>cacheable</tomlvar> = true <br><rustcmt># It's imortant to configure this to a Some value for non-static content.</rustcmt><br><rustcmt># cache_ttl_ms = </rustcmt></code></div>
                 <br>We can invoke execution of this function by requesting its route as demonstrated below. This request would work against any of the rhizo zones like euro and asia.
                 <br><br><code><bashcmd>curl</bashcmd> http://usa.rhizo.dev/text/html/3E7jPTYR8ZhJm7g4kBsbpW5ibXLwmmWX8XKfAdQmhioZ</code>
                 <br>Route CID can be checked with with<br><br>
                 <code><bashcmd>rhizo-cli</bashcmd> view route helloworld</code>
                <br> 
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2 id="deploying">Inspect Request Logs</h2>
                Responses for HTTP requests to Rhizo routes will come with a x-rhizo-stdout header. The contents of this header will be the base64 encoded contents of stdout from your module's container runtime.
                <br><h3>Example</h3>
                This example shows how to decode a x-rhizo-stdout header value of UmV0dXJuaW5nICJIZWxsbywgd29ybGQhIgo. This can be done with <inlinecode>curl -v</inlinecode> or your favorite HTTP client.
                <br><br><code><bashcmd>echo</bashcmd> "UmV0dXJuaW5nICJIZWxsbywgd29ybGQhIgo" | <bashcmd>base64</bashcmd> --decode</code>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <h2 id="deploying">Read Arguments in WASM</h2>
                This section touches on reading function arguments from within your modules container runtime. Rhizo-server translates the string representation of its types to their standard binary representation. These arguments, after undergoing parsing and serialization, are available to grab from fn_main's argument Cursor, by use of rhizosdk::arg helper functions. Arguments are to be read in the order that they are defined in the route config file. This is an expectation rhizo-server will make. Failure to follow these instructions will result in a runtime error when reading arguments from the Cursor.
                <br><br>Explore rhizosdk::arg documentation.
                <br><h3>Example</h3>
                This example demonstrates how to read two arguments, as defined in the corresponding route config. These arguments have been read in the same order that they have been defined in the config file. This is a requirement.
                <br>
                <br><code><tomlvar>route</tomlvar> = <tomlstr>"searchurls"</tomlstr><br><tomlvar>encodings</tomlvar> = [<tomlstr>"textplain"</tomlstr>, <tomlstr>"applicationjson"</tomlstr>]<br><tomlvar>arguments</tomlvar> = [<br>&emsp;&emsp;{ <tomlvar>name</tomlvar> = <tomlstr>"search_term"</tomlstr>, <tomlvar>argument_type</tomlvar> = <tomlstr>"String"</tomlstr> },<br>&emsp;&emsp;{ <tomlvar>name</tomlvar> = <tomlstr>"search_urls"</tomlstr>, <tomlvar>argument_type</tomlvar> = <tomlstr>"Vec&lt;String&gt;"</tomlstr>}<br>]<br><tomlvar>cacheable</tomlvar> = true<br><tomlvar>cache_ttl_ms = 60000</tomlvar></code>
                <br><br><code>
                <rusttype>use</rusttype> <rustvar>rhizosdk</rustvar>::<rustvar>arg</rustvar>::{read_string_arg, read_vec_of_string_arg};
                <br><br><rustvar>fn_main!</rustvar>({<rustvar>| </rustvar>arg_bytes<rustvar>: <rusttype>&mut</rusttype> <rusttype>Cursor</rusttype>&lt;<rusttype>&mut</rusttype> <rusttype>[u8]</rusttype>&gt;</rustvar> | {
                <br>&emsp;&emsp;<rusttype>let</rusttype> search_term = <rustfn>read_string_arg</rustfn>(buffer);
                <br>&emsp;&emsp;<rusttype>let</rusttype> search_urls = <rustfn>read_vec_of_string_arg</rustfn>(buffer);
                <br>&emsp;&emsp;<rustcmt>// Your logic goes here</rustcmt>
                <br>}});</code>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                <!-- TODO Let's update this example and make it a bit cleaner -->
                <h2 id="async">Write Async Code</h2>
                WASIX is a superset of WASI which brings the capability to perform asynchronous and network operations in WebAssembly. There are certain Rust crates with WASIX compatible branches that bring these capabilities to your WebAssembly project.
                <br><br><a href="https://github.com/wasix-org/">Read more</a> about WASIX compatibility in the Rust ecosystem. 
                <p>
                The Rhizo API provides a macro for running code within the tokio asynchronous runtime. This macro expects a block of code which will run asynchronously. From here you can call .await on Futures.
                <br><h3>Example:</h3>
                <br>
                <code>
                    use <rustvar>rhizosdk</rustvar>::<rusttype>*</rusttype>; <rustcmt>// Import API helper functions & macros</rustcmt><br>
                    <br> 
                    <rustvar>fn_main!</rustvar>(( <rustcmt>// Init main function & argument buffer with the fn_main macro </rustcmt><br>
                    &emsp;&emsp;<rustvar>|</rustvar>arg_buffer: <rusttype>&mut</rusttype> <rusttype>Cursor</rusttype>&lt;<rusttype>&mut</rusttype> <rusttype>[u8]</rusttype>&gt;</rustvar> <rustvar>|</rustvar> { <rustcmt>// buffer contains our arguments</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;<rustvar>async_runtime!</rustvar>({<br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<rustcmt>// We're free to use .await on futures within this block!</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<ruststr>b"Hello, world!"</ruststr>.to_vec() <br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<rustcmt>// The async_block macro expects a block that evalutes to Vec<u8>,</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<rustcmt>// the route's output bytes</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;});<br>
                    &emsp;&emsp;&emsp;&emsp;<rustvar>vec!</rustvar>[]<rustcmt> // async_runtime! will take care of writing the return value</rustcmt><br>
                    }));<br>
                </code>
                <br><br><b>Cargo.toml</b>
                <br><br><code>
                    <rustfn>[package]</rustfn>
                    <br><rustvar>name</rustvar> = <ruststr>"local-rhizo-sdk-test"</ruststr>
                    <br><rustvar>version</rustvar> = <ruststr>"0.1.0"</ruststr>
                    <br><rustvar>edition</rustvar> = <ruststr>"2021"</ruststr>

                    <br><br><rustfn>[dependencies]</rustfn>
                    <br><rustvar>rhizo-sdk</rustvar> = <ruststr>"0.2.0"</ruststr>
                    <br><rustvar>tokio</rustvar> = { <rustvar>git</rustvar> = <ruststr>"https://github.com/wasix-org/tokio.git"</ruststr>, <rustvar>features</rustvar>=[<ruststr>"full"</ruststr>], <rustvar>branch</rustvar> = <ruststr>"epoll"</ruststr> } 
                </code>
                </p>   
                       <div class="divider" style="width:24%; margin:30px 0;"></div>
 
                <h2 id="http">Make HTTP Requests</h2>
                <!-- TODO clean up this example to be more idiomatic -->
                WASIX is a superset of WASI which brings the capability to perform asynchronous and network operations in WebAssembly. There are certain Rust crates with WASIX compatible branches that bring these capabilities to your WebAssembly project.
                <br><br><a href="https://github.com/wasix-org/">Read more</a> about WASIX compatibility in the Rust ecosystem.
                <p>
                The reqwest crate is a WASIX compatible way to make HTTP requests in your function.
                <br><h3>Example:</h3>
                This example demonstrates how make an HTTP get request from your WebAssembly code. 
                <br><br>
                <code>
                    <rusttype>use</rusttype> <rustvar>rhizosdk</rustvar>::<rusttype>*</rusttype>; <rustcmt>// Import common SDK helper functions & macros</rustcmt>
                    <br><rusttype>use</rusttype> <rustvar>rhizosdk</rustvar>::<rustvar>arg</rustvar>::<rusttype>*</rusttype>; <rustcmt>// Import argument helper functions</rustcmt>
                    <br>
                    <br> 
                    <rustvar>fn_main!</rustvar>(( <rustcmt>// Init main function & argument buffer with the fn_main macro</rustcmt><br>
                    &emsp;&emsp;<rustvar>|</rustvar>arg_buffer: <rusttype>&mut</rusttype> <rusttype>Cursor</rusttype>&lt;<rusttype>&mut</rusttype> <rusttype>[u8]</rusttype>&gt;</rustvar> <rustvar>|</rustvar> { <rustcmt>// buffer contains our arguments</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;<rustvar>async_runtime!</rustvar>({ <rustcmt>// You can call .await on futures in here!</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<rusttype>let</rusttype> url_argument = <rustfn>read_string_argument</rustfn>(buffer);<br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<rustvar>reqwest</rustvar>::<rustfn>get</rustfn>(url_argument.<rustfn>get</rustfn>())<br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.await?<br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.<rustfn>text</rustfn>()<br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.await?<br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.<rustfn>as_bytes</rustfn>()<br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.<rustfn>to_vec</rustfn>()<br>
                    &emsp;&emsp;&emsp;&emsp;});<br>
                    &emsp;&emsp;&emsp;&emsp;<rustvar>vec!</rustvar>[]<rustcmt> // async_runtime! will take care of writing the return value</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;}<br>
                    ));<br>
                    
                </code> 
                <br><br><b>Cargo.toml</b>
                <br><br><code>
                <rustfn>[dependencies]</rustfn>
                <br><rustvar>rhizo-sdk</rustvar> = "0.1.4"
                <br><rustvar>reqwest</rustvar> = { git = <ruststr>"https://github.com/wasix-org/reqwest.git"</ruststr>, <rustvar>default-features</rystvar> = <ruststr>false</ruststr> }
                <br><br>
                <br><rustfn>[patch.crates-io]</rustfn>
                <br><rustvar>socket2</rustvar> = { <rustvar>git</rustvar> = <ruststr>"https://github.com/wasix-org/socket2.git"</ruststr>, <rustvar>branch</rustvar> = <ruststr>"v0.4.9"</ruststr> } 
                <br><rustvar>libc</rustvar> = { <rustvar>git</rustvar> = <ruststr>"https://github.com/wasix-org/libc.git"</ruststr> } 
                <br><rustvar>tokio</rustvar> = { <rustvar>git</rustvar> = <ruststr>"https://github.com/wasix-org/tokio.git"</ruststr>, <rustvar>branch</rustvar> = <ruststr>"epoll"</ruststr> } 
                <br><rustvar>hyper</rustvar> = { <rustvar>git</rustvar> = <ruststr>"https://github.com/wasix-org/hyper.git"</ruststr>, <rustvar>branch</rustvar> = <ruststr>"v0.14.27"</ruststr> }
                </code>
                </p> 
                <div class="doublespace"></div>
                <div class="divider" style="width:24%; margin:30px 0;"></div>
                
                <h1>Advanced Features</h1>
                <p><important><b>Important:</b> Rhizo's Storage and Streaming APIs are under rapid development. We're excited to share all the exciting features in the pipeline. Expect frequent changes to this section.</important></p>
                The rhizo-sdk provides helper functions for reading and writing bytes stored on the Solana blockchain. On-chain bytes can be used to store user data or point to off-chain bytes (coming soon!). Since blockchain storage is relatively expensive, using on-chain bytes to store content hash identifiers to off-chain bytes will be the recommended way to store data.
                <br><br>This allows the blockchain serve as the source of truth allowing the Rhizo network to inherit the security of smart-contracts and digital signatures. This combined with a design paradigm requiring the contents of on-chain data to be equal to the content hash identifier of the off-chain content it points to creates a verifiable chain of trust.
                <br><br>In the Rhizo network, user's own their own data. Requestors are responsible for pre-allocating their on-chain bytes before using routes which take an on-chain byte PDA as an argument. Route owners must pre-allocate any on-chain bytes pointed to by static PDAs within their module or point to existing ones.  
                <br><br>Requestors can pre-allocate based on the route configuration by running: 
                <br><br><code><bashcmd>rhizo-cli</bashcmd> socb alloc $KEY $SIZE_IN_BYTES </code>
                <br><br>Get the PDA, the on-chain identifier, for your newly allocated on-chain bytes with:
                <br><br><code><bashcmd>rhizo-cli</bashcmd> view socb $KEY</code>
                <p><important><b>Important:</b> Although Rhizo uses devnet SOL be mindful of on-chain storage costs. Using on-chain storage to store pointers to off-chain data like URLs or CIDs can be a cost effective way to leverage on-chain storage.</important></p>
               To manually modify the contents of on-chain bytes post-allocation
                <br><br><code><bashcmd>rhizo-cli</bashcmd> socb write $KEY $PATH_TO_NEW_CONTENTS</code>
                <br><br>
                <h2 id="http">Serve On-chain Bytes</h2>
                <p>
                <h3>Example:</h3>
                <br> This example demonstrates how to read on-chain bytes with the Rhizo SDK. The read function expects the string representation of the on-chain bytes PDA. Since async_runtime! takes care of returning a value out of the container, this route would serialize the bytes returned from read. This route now acts as a HTTP pointer to mutable on-chain data.
                <br><br> By taking PDAs as arguments we can bring on-chain user data into the context of the WASM container.
                <br><br>
                <code>
                    <rustvar>fn_main!</rustvar>(( <rustcmt>// Init main function & argument buffer with the fn_main macro</rustcmt><br>
                    &emsp;&emsp;<rustvar>|</rustvar> _ |</rustvar> { <rustcmt>// buffer contains our arguments, if applicable</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;<rustvar>async_runtime!</rustvar>({ <rustcmt>// You can call .await on futures in here!</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<rustvar>rhizosdk::onchain</rustvar>::<rustfn>read</rustfn>(<ruststr>"$BYTES_PDA"</ruststr>)<br>
                    &emsp;&emsp;&emsp;&emsp;});<br>
                    &emsp;&emsp;&emsp;&emsp;<rustvar>vec!</rustvar>[]<rustcmt> // runtime! will take care of writing the return value</rustcmt><br>
                    &emsp;&emsp;&emsp;&emsp;}<br>
                    ));<br>
                    
                </code> 
                </p>
            </div>

        </div>


    </div>


</body>
<script>
// Select all elements with the class "copy-text"
const elements = document.querySelectorAll('code');

// Add a click event listener to each element and prepend the icon to its HTML content
elements.forEach(element => {
    // Prepend the icon to each element initially
    element.insertAdjacentHTML('afterbegin', '<i class="fa fa-clipboard" style="position: absolute; right:0; top: 0; padding-top:0.3rem;padding-right:1rem;"></i> ');

    element.addEventListener('click', function() {
        const originalHTML = element.innerHTML;  // Store the original HTML (including the icon)
        const originalText = element.textContent;

        // Only perform copy if the text isn't "Copied to clipboard"
        if (!originalText.includes("Copied to clipboard")) {
            copyToClipboard(originalText);

            // Update the element's text to "Copied to clipboard" but keep the icon
            element.innerHTML = '<i class="fa fa-clipboard" style="position: absolute; right:1%; top: 10%;"></i> Copied to clipboard';

            // After 2 seconds (2000 milliseconds), revert the HTML back to the original (which includes the icon)
            setTimeout(function() {
                element.innerHTML = originalHTML;
            }, 2000);
        }
    });
});

function copyToClipboard(text) {
  // Replace all instances of &emsp; with an empty string
  const replacedText = text.replace(/&emsp;/g, '');

  // Create a temporary textarea element to store the modified text
  const tempTextArea = document.createElement('textarea');
  tempTextArea.value = replacedText;

  // Append the textarea to the DOM (it doesn't have to be visible)
  document.body.appendChild(tempTextArea);

  // Select the text in the textarea
  tempTextArea.select();

  // Copy the selected text to the clipboard
  document.execCommand('copy');

  // Remove the temporary textarea
  document.body.removeChild(tempTextArea);
}


</script>
</html>
